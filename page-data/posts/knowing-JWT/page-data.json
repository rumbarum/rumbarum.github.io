{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/knowing-JWT/","webpackCompilationHash":"09cb7ce204a4d650aff3","result":{"data":{"markdownRemark":{"id":"4e4ef2f1-a78b-54c0-9722-d091cbe80731","html":"<h2 style=\"color:rgb(9, 136, 104)\">JYP 비슷한 엔터테인먼트 회사???</h2>\n<p>는 절대 아닙니다. </p>\n<p>JWT 는 (JSON Web Tokken)의 줄임말이다. </p>\n<p>HTTP 통신은 스테이트리스(stateless) 통신을 한다. 클라이언트의 상태(state)를 서버에 저장하지 않는다(less)라는 말이다. 서버 부담도 없어지고 좋은거 아니야? 라고 볼 수도 있지만 클라이언트가 로그인한 상태인지, 권한이 있는 유저인지 확인을 매 요청 시마다 확인을 해야 한다는 말이다. 이전의 인증 방식은 세션을 사용했다. </p>\n<h3 id=\"서버기반-인증세션-old-way\"><a href=\"#%EC%84%9C%EB%B2%84%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D%EC%84%B8%EC%85%98-old-way\" aria-label=\"서버기반 인증세션 old way permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서버기반 인증(세션, Old Way)</h3>\n<p>유저가 로그인을 하게 되면, 서버측에서 유저가 현재 로그인 중이라는 인증정보를 기억하고 있어야 합니다. 그리고 이 정보를 <strong>세션</strong> 이라고 부릅니다.</p>\n<p>세션을 유지하기 위해서는 여러가지 방법이 사용되는데, 메모리, 디스크, 데이터베이스 시스템에 이를 담곤 합니다. 하지만 이 시스템엔 몇가지 문제점이 있는데, 이 문제점들은 큰 규모의 어플리케이션을 개발하는 것에 있어서 걸림돌이 되곤 했습니다.</p>\n<h3 id=\"서버-기반-인증의-문제점\"><a href=\"#%EC%84%9C%EB%B2%84-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"서버 기반 인증의 문제점 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서버 기반 인증의 문제점</h3>\n<ol>\n<li>세션을 유지하게 될 때, 로그인중인 유저의 수가 많아진다면 <strong>성능에 무리</strong>가 가게 됩니다. 이 정보를 메모리에 넣게 된다면 램이 과부화가 되고, 데이터베이스에 넣게 된다면 데이터베이스의 성능에 무리가 가게 됩니다.</li>\n<li>, <strong>서버 확장이 어려워진다</strong>는 점입니다. 여기서 서버 확장은, 단순히 서버의 사양을 업그레이드 하는 것 말고, 더 많은 트래픽을 감당하기 위하여 여러 프로세스를 돌리거나, 여러 서버 컴퓨터를 추가하여 로드밸런싱을 할때를 의미합니다. 세션을 사용하면서 분산된 시스템을 설계하는건, 세션의 정보가 분산된 프로세스간에 동기화가 되야하므로, 과정이 매우 복잡합니다.</li>\n</ol>\n<p>그래서 클라이언트가 어느 상태에 있는지 증명하는 표식(Tokken)을 통해 증명한다. JSON(JavaScrpit Object Notation) 은 정보를 저장하는 포맷을 말한다. JWT는 Claim 기반이라는 방식을 사용하는데, Claim이라는 사용자에 대한 프로퍼티나 속성을 이야기 한다. 토큰자체가 정보를 가지고 있는 방식인데, JWT는 이 Claim을 JSON을 이용해서 정의한다.</p>\n<p>Claim 기반의 토큰은 토큰 자체가 정보를 담음으로써, 토큰을 가지고 서비스나 API 접근을 제어할 때 별도의 작업이 서버에서 필요하지 않으며, 토큰 자체를 서버에서 관리할 필요가 없기 때문에 구현이 상대적으로 단순해진다.</p>\n<p>JSON은 “\\n”등 개행문자가 있기 때문에, REST API 호출시 HTTP Header등에 넣기가 매우 불편하다. 그래서, JWT에서는 이 Claim JSON 문자열을 BASE64 인코딩을 통해서 하나의 문자열로 변환한다.</p>\n<h3 id=\"토큰-기반-시스템이-제공해주는것은\"><a href=\"#%ED%86%A0%ED%81%B0-%EA%B8%B0%EB%B0%98-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%B4-%EC%A0%9C%EA%B3%B5%ED%95%B4%EC%A3%BC%EB%8A%94%EA%B2%83%EC%9D%80\" aria-label=\"토큰 기반 시스템이 제공해주는것은 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>토큰 기반 시스템이 제공해주는것은?</h3>\n<p>토큰 기반 시스템은 stateless 합니다. 이 용어의 의미는 ‘무상태’ 라는 뜻 인데요. 서버시스템측에서 더 이상 유저의 정보를 유지하지 않고, 유저가 회원 인증을 하게 될 때 <strong>토큰</strong> 을 발급해줌으로서 유저가 자기 자신임을 인증 할 수 있게 해줍니다. 발급이 된 토큰은, 토큰의 유효기간, 그리고 정보를 담고 있으며, 해싱 알고리즘을 통해 인증이 되어있어서 서버에서 검증을 통하여 처음 서버가 발급해주었던 정보가 변조되지 않았음을 보장 해 줄 수 있습니다.</p>\n<ol>\n<li>토큰을 사용함으로서, <strong>서버를 확장하게 될 때에 매우 용이해지게 됩니다</strong>. 서버 시스템이 분산이 되어있어도, 유저는 같은 토큰으로 서버에 요청을 하면 되고, 서버는 그저 그 토큰이 위조되지 않았는지만 검증을 하고 데이터베이스 조회도 할 필요 없이 바로 유저임을 신뢰하고 처리를 하면 되기 때문이죠.</li>\n<li>추가적으로, 토큰을 사용하면 <strong>플랫폼간 권한을 공유</strong> 할 수 있습니다. 페이스북 / 구글 계정을 통한 소셜 로그인을 구현을 하는데, 이게 가능한 이유도 구글과 페이스북에서 토큰기반인증 시스템을 사용하기 때문입니다. 소셜 로그인 과정에서, 구글/페이스북 플랫폼에서 로그인을 하고, 해당 플랫폼이 토큰을 발급을 해주면 우리의 백엔드 서버에서 이를 통하여 회원정보를 가져오고 우리의 서비스에 계정 생성을 하게 됩니다.</li>\n<li>마지막으로, 토큰 기반 시스템은 <strong>모바일 어플리케이션에서 사용하기에 편해집니다</strong>. 만약에 세션 기반 인증을 사용한다면, 쿠키를 사용해야 하기 때문에, 쿠키 매니저를 따로 관리해줘야 하지만, 토큰을 사용한다면 웹 요청 API 에 헤더에 넣어서 사용해주면 되기때문에 더이상 쿠키 매니저를 사용 할 필요가 없어집니다.</li>\n</ol>\n<h4 id=\"jwt-를-통해-발급된-토큰\"><a href=\"#jwt-%EB%A5%BC-%ED%86%B5%ED%95%B4-%EB%B0%9C%EA%B8%89%EB%90%9C-%ED%86%A0%ED%81%B0\" aria-label=\"jwt 를 통해 발급된 토큰 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT 를 통해 발급된 토큰</h4>\n<ul>\n<li>header, payload, signature로 구성 </li>\n<li>\n<p>header </p>\n<ul>\n<li>alg : 사용한 알고리즘(암호화 하지 않았다면 none) </li>\n<li>typ : 어떤 타입인지? </li>\n</ul>\n</li>\n<li>\n<p>payload ( claim 내용 )</p>\n<ul>\n<li>담을 값, 표현이 정해져 있는 값들이 있다.</li>\n<li>iss, sub, aud, exp, nbf, iat, jti</li>\n<li>그 외에 필요한 값들을 넣을 수 있다. </li>\n<li>주의사항</li>\n<li>페이로드정보는 secret key가 없어도 디코드가 가능하다. </li>\n<li>페이로드에 개별 식별 정보를 담을 수 있지만 영향력이 큰 정보는 담지 않는 편이 좋다. (특정 권한등의 표시 )</li>\n</ul>\n</li>\n<li>\n<p>signature</p>\n<ul>\n<li>유효한 Token 인지 검증하는 부분이다. </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"jwt의-문제점\"><a href=\"#jwt%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90\" aria-label=\"jwt의 문제점 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT의 문제점</h3>\n<ol>\n<li>길이</li>\n<li>Claim에 넣는 데이터와 JWT 토큰의 길이는 비례한다. 클라이언트가 요청할 때마다 헤더에 토큰이 붙어 전송되므로, 네트워크 대역폭 낭비가 심하다.</li>\n<li>한번 발급된 토큰 값의 수정 및 폐기 불가능</li>\n<li>JWT는 토큰 내에 모든 정보를 가지고 있어 한번 발급된 토큰을 서버가 변경할 수 없다. 그렇기 때문에 Reserved Claims에 expiration time을 꼭 지정해주고, refresh token 등을 통해 토큰을 재발급해주어야 한다.</li>\n<li>보안</li>\n<li>기본적으로 Claim을 암호화 하지 않고 단순히 base64 인코딩만을 하기 때문에 토큰이 타인에게 노출되면 사용자 정보가 유출될 수 있다.</li>\n<li>Payload에 권한과 관련된 Claim을 넣어 그 값으로만 사용자를 식별한다면 토큰 값 조작으로 인가되지 않은 접근 권한을 획득할 수 있다.</li>\n</ol>\n<h3 id=\"보안-고려사항\"><a href=\"#%EB%B3%B4%EC%95%88-%EA%B3%A0%EB%A0%A4%EC%82%AC%ED%95%AD\" aria-label=\"보안 고려사항 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>보안 고려사항</h3>\n<ol>\n<li>Signature Stripping</li>\n<li>JWT 공격 방법 중 signature를 제거하는 것이 흔하다. 잘못된 검증으로 unsigned 상태인 토큰을 유효한 토큰으로 인식할 수 있으므로 애플리케이션에서 unsigned 토큰을 유효하지 않은 토큰으로 인식하도록 하면 된다.</li>\n<li>CSRF(Cross-Site Request Forgery)</li>\n<li>토큰이 쿠키에 저장되는 경우, short-lived JWT를 이용하거나, origin 검증을 통해 CSRF 공격을 방어할 수 있다. 토큰이 쿠키에 저장되어있지 않으면 CSRF 공격은 불가능하다.</li>\n<li>XSS(Cross-Site Scripting)</li>\n<li>액세스 토큰이 만료되기 전에 유출되면, 리소스에 접근하는 용도로 사용될 수 있다. 클라이언트에서 보낸 데이터를 반드시 sanitize 하고, 쿠키에 대해선 HttpOnly flag를 설정해 스크립트 코드로 접근하는 것을 막아야 한다.</li>\n</ol>","fields":{"slug":"/posts/knowing-JWT/","tagSlugs":["/tag/jwt/","/tag/backend/","/tag/web-develop/"]},"frontmatter":{"date":"2019-11-05T01:23:45.678Z","description":"유저인증을 위한 방법의 하나인 JWT","tags":["JWT","Backend","WebDevelop"],"title":"JWT를 알아보자"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/knowing-JWT/"}}}